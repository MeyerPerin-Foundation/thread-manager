from datetime import datetime
import cosmosdb
import social_media_poster
import blog_reader
import random
import ai
import logging

logger = logging.getLogger("ContGen")
logger.setLevel(logging.INFO)


def _calculate_date_difference(target_date):
    try:
        # Convert the fixed date string to a datetime object
        target_date_obj = datetime.strptime(target_date, "%Y-%m-%d").date()

        # Get today's date
        today = datetime.today().date()

        # Calculate the difference in days
        difference = (target_date_obj - today).days

        return difference
    except ValueError:
        print("Error in calculating the date difference")
        return None


def _generate_days_until_dict(
    event_name,
    event_date,
    threads=False,
    instagram=False,
    bluesky=False,
    linkedin=False,
    plural=False,
    stop=-7,
):
    print(f"Calculating the days until {event_name} on {event_date}")

    # Calculate the difference in days
    difference = _calculate_date_difference(event_date)

    if difference is None:
        print(f"Invalid date format {event_date}. Please use 'YYYY-MM-DD'.")
        return None
    else:
        print(f"Days until {event_name}: {difference}")

    if difference < stop:
        print(
            f"Event {event_name} happened more than {abs(max)} days ago. No content will be generated."
        )
        return None

    # If the difference is more than 90 days, it should be a multiple of 100 or 365
    if difference > 90:
        if not ((difference % 100 == 0) and (difference % 365 == 0)):
            return None

    text = ""

    if plural:
        verb_before = "are"
        verb_after = "were"
    else:
        verb_before = "is"
        verb_after = "was"

    if difference > 1:
        text = f"There are {difference} days until {event_name}"
    elif difference == 1:
        # capitalize the first letter of the event name
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_before} tomorrow!"
    elif difference == 0:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_before} today!"
    elif difference == -1:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_after} {abs(difference)} yesterday!"
    else:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_after} {abs(difference)} days ago!"

    print(f"Text generated by days_until: {text}")

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": text,
        "hashtags": ["DaysUntil"],
        "threads": threads,
        "instagram": instagram,
        "bluesky": bluesky,
        "linkedin": linkedin,
    }

    return post_data


def generate_and_post_motd():
    motd_dict = cosmosdb.get_motd()
    if not motd_dict:
        return "No MotD for today", 204

    motd_dict["hashtags"] = ["OnThisDay"]
    return social_media_poster.post(motd_dict)


def generate_and_post_midterms_countdown():
    midterms_dict = _generate_days_until_dict(
        "the US midterms", "2026-11-03", bluesky=True, threads=True, plural=True, stop=0
    )

    if not midterms_dict:
        return "No midterms content", 204

    return social_media_poster.post(midterms_dict)


def generate_and_post_severance_s2_countdown():
    severance_dict = _generate_days_until_dict(
        "Severance Season 2",
        "2025-01-17",
        bluesky=True,
        threads=True,
        plural=False,
        stop=7,
    )

    if not severance_dict:
        return "No Severance S2 content", 204

    return social_media_poster.post(severance_dict)


def generate_and_post_ungovernable():
    ungovernable_dict = cosmosdb.get_random_ungovernable()

    if not ungovernable_dict:
        print("No ungovernable content found")
        return "No ungovernable content found", 204

    message = ungovernable_dict["title"]

    # remove high unicode characters
    message = message.encode("ascii", "ignore").decode("ascii")

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": ungovernable_dict["blob_url"],
        "hashtags": ["BecomeUngovernable"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False,
    }

    ungovernable_dict["title"] = message
    cosmosdb.update_ungovernable_posted(ungovernable_dict)

    return social_media_poster.post(post_data)


def generate_and_post_too_far():
    too_far_dict = cosmosdb.get_random_too_far()

    if not too_far_dict:
        print("No too far content found")
        return "No too far content found", 204

    # remove high unicode characters
    message = too_far_dict["title"]
    message = message.encode("ascii", "ignore").decode("ascii")

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": too_far_dict["blob_url"],
        "hashtags": ["GoneTooFar"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False,
    }

    too_far_dict["title"] = message
    cosmosdb.update_too_far_posted(too_far_dict)

    return social_media_poster.post(post_data)


def generate_and_post_birdbuddy_picture():
    birdbuddy_list = cosmosdb.get_best_birdbuddy()

    if not birdbuddy_list:
        print("No Bird Buddy content found")
        return "No Bird Buddy content found", 204

    # create a list with the image urls
    image_url_list = [birdbuddy_dict["blob_url"] for birdbuddy_dict in birdbuddy_list]
    best_image = ai.choose_best_bird_image(image_url_list)

    # get the birdbuddy_dict for the best image
    birdbuddy_dict = next(
        (item for item in birdbuddy_list if item["blob_url"] == best_image), None
    )

    species = birdbuddy_dict.get("species", None)
    blob_url = birdbuddy_dict.get("blob_url", None)
    created_at = birdbuddy_dict.get("created_at", None)
    # feeder_name = birdbuddy_dict.get("feeder_name", None)
    location = birdbuddy_dict.get("location", "Fulshear,  Texas")

    # Create a dictionary with voice options and weights and choose a random one.
    voices = cosmosdb.get_bird_description_voice_options()

    # Choose a random voice based on the weights
    weights = [voice["weight"] for voice in voices]
    voice = random.choices(voices, weights, k=1)[0]["voice"]

    # get the caption for the bird picture
    caption = ai.generate_caption_for_bird_picture(
        blob_url, species, created_at, location, voice
    )

    # if the message is in quotes, remove the quotes
    if caption.startswith('"') and caption.endswith('"'):
        caption = caption[1:-1]

    caption = f'As {voice}: "{caption}"'

    # # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": f"{caption}",
        "emojis": ["ðŸª¶"],
        "image": blob_url,
        "hashtags": ["birds"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False,
        "url": "https://t.ly/birdb",
        "url_title": "ðŸ“·: Birdbuddy",
    }

    message, code = social_media_poster.post(post_data)
    logger.info(f"Threads post result was {code}: {message}")

    cosmosdb.update_birdbuddy_posted(birdbuddy_dict)

    return message, code


def generate_and_post_blog_promo():
    blog_post_metadata = cosmosdb.get_latest_blog_post()

    if not blog_post_metadata:
        logger.info("No too far content found")
        return "No too far content found", 204

    # Different promo for LinkedIn and Threads/Bluesky
    bt_message = blog_reader.blog_bt_summary(blog_post_metadata["url"])
    bt_post_data = {
        "text": bt_message,
        "url": blog_post_metadata["url"],
        "hashtags": ["BlogPost"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False,
        "url_title": "Read blog post",
    }

    social_media_poster.post(bt_post_data)

    linkedin_message = blog_reader.blog_li_summary(blog_post_metadata["url"])
    linkedin_post_data = {
        "text": linkedin_message,
        "url": blog_post_metadata["url"],
        "threads": False,
        "instagram": False,
        "bluesky": False,
        "linkedin": True,
    }

    social_media_poster.post(linkedin_post_data)
    cosmosdb.update_blog_posted(blog_post_metadata)

    return "Accepted", 202


def generate_and_post_bsky_reminder():
    post_data = {
        "text": "A semi-regular reminder that I am also on Bluesky at @lucasmeyer.bsky.social.",
        "url": "https://bsky.app/profile/lucasmeyer.bsky.social",
        "threads": True,
        "instagram": False,
        "bluesky": False,
        "linkedin": True,
    }

    social_media_poster.post(post_data)
    return "Accepted", 202


if __name__ == "__main__":
    # print(generate_and_post_birdbuddy_picture())
    # print(generate_and_post_severance_s2_countdown())
    print(generate_and_post_birdbuddy_picture())
