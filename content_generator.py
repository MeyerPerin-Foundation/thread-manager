from datetime import datetime
import cosmosdb
import social_media_poster
from openai import OpenAI
import app_config

def calculate_date_difference(target_date):
    try:
        # Convert the fixed date string to a datetime object
        target_date_obj = datetime.strptime(target_date, '%Y-%m-%d').date()
        
        # Get today's date
        today = datetime.today().date()
        
        # Calculate the difference in days
        difference = (target_date_obj - today).days
        
        return difference
    except ValueError:
        print("Error in calculating the date difference")
        return None


def days_until(event_name, event_date, threads=False, instagram=False, bluesky=False, linkedin=False):
    
    print(f"Calculating the days until {event_name} on {event_date}")

    # Calculate the difference in days
    difference = calculate_date_difference(event_date)

    if difference is None:
        print(f"Invalid date format {event_date}. Please use 'YYYY-MM-DD'.")
        return None
    else:
        print(f"Days until {event_name}: {difference}")   

    text = None 
    if difference > 1:
        text = f"There are {difference} days until {event_name}"
    elif difference == 1:
        # capitalize the first letter of the event name
        event_name = event_name.capitalize()
        text =  f"{event_name} is tomorrow!"
    elif difference == 0:
        event_name = event_name.capitalize()
        text = f"{event_name} is today!"
    else:
        event_name = event_name.capitalize()
        text = f"{event_name} has passed {difference} days ago."
    
    print(f"Text generated by days_until: {text}")
    
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": text,
        "hashtags": ["DaysUntil"],
        "threads": threads,
        "instagram": instagram,
        "bluesky": bluesky,
        "linkedin": linkedin
    }

    return post_data

def generate_and_post_motd():
    motd_dict = cosmosdb.get_motd()
    if not motd_dict:
        return "No MotD for today", 200
    
    motd_dict["hashtags"] = ["OnThisDay"]
    return social_media_poster.post(motd_dict)

def generate_and_post_midterms_countdown():
    midterms_dict = days_until('the next midterms', '2026-11-03', bluesky=True)
    print(f"Generated midterms_dict: {midterms_dict}")
    return social_media_poster.post(midterms_dict)

def generate_and_post_ungovernable():
    ungovernable_dict = cosmosdb.get_random_ungovernable()

    if not ungovernable_dict:
        print("No ungovernable content found")
        return "No ungovernable content found", 404
    
    message = ungovernable_dict["title"]

    # remove high unicode characters
    message = message.encode('ascii', 'ignore').decode('ascii')
        
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": ungovernable_dict["blob_url"],
        "hashtags": ["BecomeUngovernable"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    return social_media_poster.post(post_data)

def generate_and_post_too_far():
    too_far_dict = cosmosdb.get_random_too_far()    

    if not too_far_dict:
        print("No too far content found")
        return "No too far content found", 404

    # remove high unicode characters
    message = too_far_dict["title"]
    message = message.encode('ascii', 'ignore').decode('ascii')    

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": too_far_dict["blob_url"],
        "hashtags": ["GoneTooFar"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    return social_media_poster.post(post_data)

def generate_and_post_birdbuddy_picture():
    birdbuddy_dict = cosmosdb.get_random_birdbuddy()

    if not birdbuddy_dict:
        print("No Bird Buddy content found")
        return "No Bird Buddy content found", 404
    
    species = birdbuddy_dict.get("species", None)
    blob_url = birdbuddy_dict.get("blob_url", None)

    # get the caption for the bird picture
    caption = generate_caption_for_bird_picture(blob_url, species)
   
    # if the message is in quotes, remove the quotes
    if caption.startswith('"') and caption.endswith('"'):
        caption = caption[1:-1]

  # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": f"{caption}",
        "emojis": ["ðŸª¶"],
        "image": blob_url,
        "hashtags": ["Birds"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    cosmosdb.update_birdbuddy_posted(birdbuddy_dict)

    return social_media_poster.post(post_data)


def generate_caption_for_bird_picture(image_url, species=None):

    client = OpenAI(api_key=app_config.OPENAI_API_KEY)

    if species:
        sp = f" of a {species} "
    else:
        sp = ""

    prompt = f"Generate a caption for this bird image {sp} that was captured on a bird feeder camera.\n"
    prompt += f"Do not assume the bird's gender. Do not assume the time of the day unless explicitly stated.\n"
    prompt += f"The caption will be used in a social media post and should be less than 200 characters.\n"
    prompt += f"The caption should be suitable for a professional brand, although it can be funny.\n"
    prompt += f"Do not use emojis or hashtags.  Do not ask for engagement. Do not ask questions.\n"

    response = client.chat.completions.create(
        model="gpt-4o", 
        messages=[
            {"role": "system", "content": "You are a photographer and social media content creator"},
            {"role": "user", "content": [
                {"type": "text", "text": prompt},
                {"type": "image_url", "image_url": {
                    "url": image_url}}
            ]}
        ],
    )

    return response.choices[0].message.content
