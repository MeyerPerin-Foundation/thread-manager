from datetime import datetime
import cosmosdb
import social_media_poster
from openai import AzureOpenAI
import app_config
import blog_reader
import pytz
import random
import ai

def _calculate_date_difference(target_date):
    try:
        # Convert the fixed date string to a datetime object
        target_date_obj = datetime.strptime(target_date, '%Y-%m-%d').date()
        
        # Get today's date
        today = datetime.today().date()
        
        # Calculate the difference in days
        difference = (target_date_obj - today).days
        
        return difference
    except ValueError:
        print("Error in calculating the date difference")
        return None

def _generate_days_until_dict(event_name, event_date, threads=False, instagram=False, bluesky=False, linkedin=False, plural=False, stop=-7):
    
    print(f"Calculating the days until {event_name} on {event_date}")

    # Calculate the difference in days
    difference = _calculate_date_difference(event_date)

    if difference is None:
        print(f"Invalid date format {event_date}. Please use 'YYYY-MM-DD'.")
        return None
    else:
        print(f"Days until {event_name}: {difference}")

    if difference < stop:
        print(f"Event {event_name} happened more than {abs(max)} days ago. No content will be generated.")
        return None   

    if not(difference % 365 == 0 or difference % 100 == 0 or difference <= 90):
        return None
    
    text = "" 

    if plural:
        verb_before = "are"
        verb_after = "were"
    else:
        verb_before = "is"
        verb_after = "was"

    if difference > 1:
        text = f"There are {difference} days until {event_name}"
    elif difference == 1:
        # capitalize the first letter of the event name
        event_name = event_name.capitalize()
        text =  f"{event_name} {verb_before} tomorrow!"
    elif difference == 0:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_before} today!"
    elif difference == -1:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_after} {abs(difference)} yesterday!"
    else:
        event_name = event_name.capitalize()
        text = f"{event_name} {verb_after} {abs(difference)} days ago!"
    
    print(f"Text generated by days_until: {text}")
    
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": text,
        "hashtags": ["DaysUntil"],
        "threads": threads,
        "instagram": instagram,
        "bluesky": bluesky,
        "linkedin": linkedin
    }

    return post_data

def generate_and_post_motd():
    motd_dict = cosmosdb.get_motd()
    if not motd_dict:
        return "No MotD for today", 204
    
    motd_dict["hashtags"] = ["OnThisDay"]
    return social_media_poster.post(motd_dict)

def generate_and_post_midterms_countdown():
    midterms_dict = _generate_days_until_dict('the US midterms', '2026-11-03', bluesky=True, threads=True, plural=True, stop=0)
    
    if not midterms_dict:
        return "No midterms content", 204

    return social_media_poster.post(midterms_dict)

def generate_and_post_severance_s2_countdown():
    severance_dict = _generate_days_until_dict('Severance Season 2', '2025-01-17', bluesky=True, threads=True, plural=False, stop=7)
    
    if not severance_dict:
        return "No Severance S2 content", 204

    return social_media_poster.post(severance_dict)

def generate_and_post_ungovernable():
    ungovernable_dict = cosmosdb.get_random_ungovernable()

    if not ungovernable_dict:
        print("No ungovernable content found")
        return "No ungovernable content found", 204
    
    message = ungovernable_dict["title"]

    # remove high unicode characters
    message = message.encode('ascii', 'ignore').decode('ascii')
        
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": ungovernable_dict["blob_url"],
        "hashtags": ["BecomeUngovernable"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    ungovernable_dict["title"] = message
    cosmosdb.update_ungovernable_posted(ungovernable_dict)

    return social_media_poster.post(post_data)

def generate_and_post_too_far():
    too_far_dict = cosmosdb.get_random_too_far()    

    if not too_far_dict:
        print("No too far content found")
        return "No too far content found", 204

    # remove high unicode characters
    message = too_far_dict["title"]
    message = message.encode('ascii', 'ignore').decode('ascii')    

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": too_far_dict["blob_url"],
        "hashtags": ["GoneTooFar"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    too_far_dict["title"] = message
    cosmosdb.update_too_far_posted(too_far_dict)

    return social_media_poster.post(post_data)

def generate_and_post_birdbuddy_picture():

    birdbuddy_list = cosmosdb.get_best_birdbuddy()

    if not birdbuddy_list:
        print("No Bird Buddy content found")
        return "No Bird Buddy content found", 204

    # create a list with the image urls
    image_url_list = [birdbuddy_dict["blob_url"] for birdbuddy_dict in birdbuddy_list]
    best_image = ai.choose_best_bird_image(image_url_list)
    
    # get the birdbuddy_dict for the best image
    birdbuddy_dict = next((item for item in birdbuddy_list if item["blob_url"] == best_image), None)

    species = birdbuddy_dict.get("species", None)
    blob_url = birdbuddy_dict.get("blob_url", None)
    created_at = birdbuddy_dict.get("created_at", None)
    feeder_name = birdbuddy_dict.get("feeder_name", None)
    location = birdbuddy_dict.get("location", "Fulshear,  Texas")

    # Create a dictionary with voice options and weights and choose a random one. 
    voices = [{"voice": "Sir David Attenborough","weight": 4},
              {"voice": "a fashion critic","weight": 4},
              {"voice": "a Shakespearean poet","weight": 4},
              {"voice": "a gossip blogger","weight": 4},
              {"voice": "a detective noir","weight": 4},
              {"voice": "a stand-up comedian","weight": 4},
              {"voice": "Steve Irwin","weight": 4}]
    

    # Choose a random voice based on the weights
    voice = random.choices(voices, weights=[voice["weight"] for voice in voices], k=1)[0]["voice"]

    # get the caption for the bird picture
    caption = generate_caption_for_bird_picture(blob_url, species, created_at, location, voice)
   
    # if the message is in quotes, remove the quotes
    if caption.startswith('"') and caption.endswith('"'):
        caption = caption[1:-1]

    caption = f'In the voice of {voice}: "{caption}"\n\nCaptured with Birdbuddy.'

  # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": f"{caption}",
        "emojis": ["ðŸª¶"],
        "image": blob_url,
        "hashtags": ["Birds"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    cosmosdb.update_birdbuddy_posted(birdbuddy_dict)

    return social_media_poster.post(post_data)

def generate_caption_for_bird_picture(image_url, species=None, created_at=None, location=None, voice=None):

    client = AzureOpenAI(azure_endpoint=app_config.AZURE_OPENAI_ENDPOINT, 
                         api_key=app_config.AZURE_OPENAI_KEY, 
                         api_version=app_config.AZURE_OPENAI_API_VERSION)

    if species:
        sp = f" of a {species} "
    else:
        sp = ""

    if created_at:
        # Convert the created_at iso formatted string to a datetime object
        utc_time = datetime.fromisoformat(created_at.replace("Z", "+00:00"))

                # Define the Central Time timezone
        central_tz = pytz.timezone("US/Central")

        # Convert UTC time to Central Time
        central_time = utc_time.astimezone(central_tz)

        # Format the date and time
        picture_time = central_time.strftime("%B %d, %Y at %I:%M %p")

        pt = f" on {picture_time} "
    else:
        pt = ""

    if location:
        loc = f" in {location}"
    else:
        loc = ""

    if not voice:
        voice = "Sir David Attenborough"
    
    prompt = cosmosdb.get_prompt("bird_caption")
    prompt = prompt.replace("{sp}", sp)
    prompt = prompt.replace("{pt}", pt)
    prompt = prompt.replace("{loc}", loc)
    prompt = prompt.replace("{voice}", voice)

    response = client.chat.completions.create(
        model="gpt-4o", 
        messages=[
            {"role": "system", "content": "You are a photographer and social media content creator"},
            {"role": "user", "content": [
                {"type": "text", "text": prompt},
                {"type": "image_url", "image_url": {
                    "url": image_url}}
            ]},
        ],
        temperature=0.8,
    )

    return response.choices[0].message.content

def generate_and_post_blog_promo():
    blog_post_metadata = cosmosdb.get_latest_blog_post()    

    if not blog_post_metadata:
        print("No too far content found")
        return "No too far content found", 204

    # Different promo for LinkedIn and Threads/Bluesky
    bt_message = blog_reader.blog_bt_summary(blog_post_metadata["url"])
    bt_post_data = {
        "text": bt_message,
        "url": blog_post_metadata["url"],
        "hashtags": ["BlogPost"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    social_media_poster.post(bt_post_data)

    linkedin_message = blog_reader.blog_li_summary(blog_post_metadata["url"])
    linkedin_post_data = {
        "text": linkedin_message,
        "url": blog_post_metadata["url"],
        "threads": False,
        "instagram": False,
        "bluesky": False,
        "linkedin": True
    }
    
    social_media_poster.post(linkedin_post_data)
    cosmosdb.update_blog_posted(blog_post_metadata)

    return "Accepted", 202 

if __name__ == "__main__":
    # print(generate_and_post_birdbuddy_picture())
    print(generate_and_post_severance_s2_countdown())
