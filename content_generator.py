from datetime import datetime
import cosmosdb
import social_media_poster
from openai import OpenAI
import app_config
import blog_reader
import pytz

def calculate_date_difference(target_date):
    try:
        # Convert the fixed date string to a datetime object
        target_date_obj = datetime.strptime(target_date, '%Y-%m-%d').date()
        
        # Get today's date
        today = datetime.today().date()
        
        # Calculate the difference in days
        difference = (target_date_obj - today).days
        
        return difference
    except ValueError:
        print("Error in calculating the date difference")
        return None

def days_until(event_name, event_date, threads=False, instagram=False, bluesky=False, linkedin=False):
    
    print(f"Calculating the days until {event_name} on {event_date}")

    # Calculate the difference in days
    difference = calculate_date_difference(event_date)

    if difference is None:
        print(f"Invalid date format {event_date}. Please use 'YYYY-MM-DD'.")
        return None
    else:
        print(f"Days until {event_name}: {difference}")   

    text = None 
    if difference > 1:
        text = f"There are {difference} days until {event_name}"
    elif difference == 1:
        # capitalize the first letter of the event name
        event_name = event_name.capitalize()
        text =  f"{event_name} is tomorrow!"
    elif difference == 0:
        event_name = event_name.capitalize()
        text = f"{event_name} is today!"
    else:
        event_name = event_name.capitalize()
        text = f"{event_name} has passed {difference} days ago."
    
    print(f"Text generated by days_until: {text}")
    
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": text,
        "hashtags": ["DaysUntil"],
        "threads": threads,
        "instagram": instagram,
        "bluesky": bluesky,
        "linkedin": linkedin
    }

    return post_data

def generate_and_post_motd():
    motd_dict = cosmosdb.get_motd()
    if not motd_dict:
        return "No MotD for today", 200
    
    motd_dict["hashtags"] = ["OnThisDay"]
    return social_media_poster.post(motd_dict)

def generate_and_post_midterms_countdown():
    midterms_dict = days_until('the next midterms', '2026-11-03', bluesky=True)
    print(f"Generated midterms_dict: {midterms_dict}")
    return social_media_poster.post(midterms_dict)

def generate_and_post_ungovernable():
    ungovernable_dict = cosmosdb.get_random_ungovernable()

    if not ungovernable_dict:
        print("No ungovernable content found")
        return "No ungovernable content found", 404
    
    message = ungovernable_dict["title"]

    # remove high unicode characters
    message = message.encode('ascii', 'ignore').decode('ascii')
        
    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": ungovernable_dict["blob_url"],
        "hashtags": ["BecomeUngovernable"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    ungovernable_dict["title"] = message
    cosmosdb.update_ungovernable_posted(ungovernable_dict)

    return social_media_poster.post(post_data)

def generate_and_post_too_far():
    too_far_dict = cosmosdb.get_random_too_far()    

    if not too_far_dict:
        print("No too far content found")
        return "No too far content found", 404

    # remove high unicode characters
    message = too_far_dict["title"]
    message = message.encode('ascii', 'ignore').decode('ascii')    

    # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": message,
        "image": too_far_dict["blob_url"],
        "hashtags": ["GoneTooFar"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    too_far_dict["title"] = message
    cosmosdb.update_too_far_posted(too_far_dict)

    return social_media_poster.post(post_data)

def generate_and_post_birdbuddy_picture(latest=True):

    if latest:
        birdbuddy_dict = cosmosdb.get_latest_birdbuddy()
    else:
        birdbuddy_dict = cosmosdb.get_random_birdbuddy()

    if not birdbuddy_dict:
        print("No Bird Buddy content found")
        return "No Bird Buddy content found", 404
    
    species = birdbuddy_dict.get("species", None)
    blob_url = birdbuddy_dict.get("blob_url", None)
    created_at = birdbuddy_dict.get("created_at", None)
    location = "Fulshear, TX"

    # get the caption for the bird picture
    caption = generate_caption_for_bird_picture(blob_url, species, created_at, location)
   
    # if the message is in quotes, remove the quotes
    if caption.startswith('"') and caption.endswith('"'):
        caption = caption[1:-1]

  # Create a dictionary with the post text and the social media platforms to post to
    post_data = {
        "text": f"{caption}",
        "emojis": ["ðŸª¶"],
        "image": blob_url,
        "hashtags": ["Birds"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    cosmosdb.update_birdbuddy_posted(birdbuddy_dict)

    return social_media_poster.post(post_data)

def generate_caption_for_bird_picture(image_url, species=None, created_at=None, location=None):

    client = OpenAI(api_key=app_config.OPENAI_API_KEY)

    if species:
        sp = f" of a {species} "
    else:
        sp = ""

    if created_at:
        # Convert the created_at iso formatted string to a datetime object
        utc_time = datetime.fromisoformat(created_at.replace("Z", "+00:00"))

                # Define the Central Time timezone
        central_tz = pytz.timezone("US/Central")

        # Convert UTC time to Central Time
        central_time = utc_time.astimezone(central_tz)

        # Format the date and time
        picture_time = central_time.strftime("%B %d, %Y at %I:%M %p")

        pt = f" on {picture_time} "
    else:
        pt = ""

    if location:
        loc = f" in {location}"
    else:
        loc = ""
    
    prompt = cosmosdb.get_prompt("bird_caption")
    prompt = prompt.replace("{sp}", sp)
    prompt = prompt.replace("{pt}", pt)
    prompt = prompt.replace("{loc}", loc)

    response = client.chat.completions.create(
        model="gpt-4o", 
        messages=[
            {"role": "system", "content": "You are a photographer and social media content creator"},
            {"role": "user", "content": [
                {"type": "text", "text": prompt},
                {"type": "image_url", "image_url": {
                    "url": image_url}}
            ]},
        ],
        temperature=0.8,
    )

    return response.choices[0].message.content

def generate_and_post_blog_promo():
    blog_post_metadata = cosmosdb.get_latest_blog_post()    

    if not blog_post_metadata:
        print("No too far content found")
        return "No too far content found", 404

    # Different promo for LinkedIn and Threads/Bluesky
    bt_message = blog_reader.blog_bt_summary(blog_post_metadata["url"])
    bt_post_data = {
        "text": bt_message,
        "url": blog_post_metadata["url"],
        "threads": True,
        "instagram": False,
        "bluesky": True,
        "linkedin": False
    }

    social_media_poster.post(bt_post_data)

    linkedin_message = blog_reader.blog_li_summary(blog_post_metadata["url"])
    linkedin_post_data = {
        "text": linkedin_message,
        "url": blog_post_metadata["url"],
        "threads": False,
        "instagram": False,
        "bluesky": False,
        "linkedin": True
    }
    
    social_media_poster.post(linkedin_post_data)
    cosmosdb.update_blog_posted(blog_post_metadata)

    return "Accepted", 202 
